# internal_chat_mcp

internal_chat_mcp MCP server

This project is an MCP (Model Context Protocol) server generated by `mcp-forge`. It provides a starting point for building your own server with custom tools and resources.

## Project Structure

```
./
├── internal_chat_mcp/           # Python package for your server code
│   ├── __init__.py              # Package initialization
│   ├── server.py                # Unified server entry point with mode selection
│   ├── server_stdio.py          # Implementation for stdio transport
│   ├── server_sse.py            # Implementation for SSE transport (HTTP)
│   ├── interfaces/              # Base classes/interfaces for tools and resources
│   │   ├── __init__.py
│   │   ├── resource.py
│   │   └── tool.py
│   ├── resources/               # Implementation of resources
│   │   ├── __init__.py
│   │   ├── hello_world.py       # Example static resource
│   │   └── user_profile.py      # Example dynamic resource with URI parameters
│   ├── services/                # Services for managing tools and resources
│   │   ├── __init__.py
│   │   ├── resource_service.py  # Handles resource registration and routing
│   │   └── tool_service.py      # Handles tool registration and execution
│   └── tools/                   # Implementation of tools
│       ├── __init__.py
│       └── hello_world.py       # Example tool with input/output schemas
├── pyproject.toml               # Project metadata and dependencies (using Hatch)
└── README.md                    # This file
```

## Setup

This project uses `uv` for dependency management. Ensure you have `uv` installed (`pip install uv`).

1.  **Navigate** into the project directory:
    ```bash
    cd internal_chat_mcp
    ```
2.  **Create a virtual environment** and install dependencies:
    ```bash
    uv venv
    uv pip install -e .
    ```

## Running the Server

The server can run in two modes: `stdio` (standard input/output) or `sse` (HTTP Server-Sent Events). You must specify the desired mode using the `--mode` parameter.

### Using the Command Line Script

After installation, you can use the `internal_chat_mcp` command directly:

```bash
# Run in stdio mode
internal_chat_mcp --mode=stdio

# Run in SSE mode (defaults to http://0.0.0.0:6969)
internal_chat_mcp --mode=sse

# Run in SSE mode with custom host/port
internal_chat_mcp --mode=sse --host 127.0.0.1 --port 8000

# Run in SSE mode with auto-reload for development
internal_chat_mcp --mode=sse --reload
```

### Using Python Module

Alternatively, you can run the server as a Python module:

```bash
# Using the unified server script
uv run -m internal_chat_mcp.server --mode=stdio
uv run -m internal_chat_mcp.server --mode=sse

# Or call the specific implementations directly
uv run -m internal_chat_mcp.server_stdio
uv run -m internal_chat_mcp.server_sse
```

## Developing Your Server

### Development Mode with Auto-Reload

For faster development with the SSE mode, you can use the auto-reload feature which automatically restarts the server when code changes are detected:

```bash
internal_chat_mcp --mode=sse --reload
```

This is particularly useful during active development as you won't need to manually restart the server after each code change.

### Adding New Tools

1.  **Create a new Python file** in the `internal_chat_mcp/tools/` directory (e.g., `my_tool.py`).
2.  **Define your tool class** inheriting from `Tool` (from `internal_chat_mcp.interfaces.tool`).
3.  **Define an input model** inheriting from `BaseToolInput` for your tool's parameters using Pydantic.
4.  **Implement the `execute` method** containing your tool's logic.
5.  **Import and add your tool class** to the `__all__` list in `internal_chat_mcp/tools/__init__.py`.
6.  **Instantiate your tool** in the `get_available_tools` function within `internal_chat_mcp/server_stdio.py` and `internal_chat_mcp/server_sse.py`.

### Adding New Resources

1.  **Create a new Python file** in the `internal_chat_mcp/resources/` directory (e.g., `my_resource.py`).
2.  **Define your resource class** inheriting from `Resource` (from `internal_chat_mcp.interfaces.resource`).
3.  **Define the required class attributes**: `name`, `description`, `uri`, `mime_type`.
4.  **Implement the `read` method**. For dynamic URIs (e.g., `data://{item_id}`), parameters are passed as keyword arguments to `read` (e.g., `read(item_id=...)`).
5.  **Import and add your resource class** to the `__all__` list in `internal_chat_mcp/resources/__init__.py`.
6.  **Instantiate your resource** in the `get_available_resources` function within `internal_chat_mcp/server_stdio.py` and `internal_chat_mcp/server_sse.py`.

### Service Layer

- `ToolService`: Manages the registration and execution of tools. It dynamically creates handler functions based on tool input schemas.
- `ResourceService`: Manages the registration and reading of resources. It handles routing for static and dynamic URIs.

## Learn More About MCP

Visit the official [Model Context Protocol Documentation](https://modelcontextprotocol.io/) for detailed information about the protocol, concepts, and advanced features.

## Advanced Message Retrieval & Filtering (v0.1.0+)

### MessageFilter Model

The `MessageFilter` model allows for flexible, future-proof filtering of chat messages. All fields are optional and have sensible defaults. This model is used for both REST and WebSocket tools.

```python
class MessageFilter(BaseModel):
    user: Optional[str] = None           # For unread tracking
    channels: Optional[List[str]] = None # If None, defaults to ["general"]
    dm_only: Optional[bool] = None
    mention_only: Optional[bool] = None
    content_regex: Optional[str] = None
    from_user: Optional[str] = None
    before: Optional[str] = None
    after: Optional[str] = None
    sort: Optional[str] = "asc"
    limit: Optional[int] = 20
```

### REST API Usage

#### Simple (Get Unread)
```bash
curl -X POST 'http://localhost:8000/api/team/<team_id>/messages/query' \
  -H 'Content-Type: application/json' \
  -d '{"user": "Cline"}'
```
Returns all unread messages for user `Cline` in the default channel ("general"), up to 20 messages.

#### Advanced (Custom Filters)
```bash
curl -X POST 'http://localhost:8000/api/team/<team_id>/messages/query' \
  -H 'Content-Type: application/json' \
  -d '{
    "user": "Cline",
    "channels": ["dev", "support"],
    "mention_only": true,
    "content_regex": "@Cline|urgent",
    "limit": 50
  }'
```
Returns up to 50 unread messages for `Cline` in "dev" or "support" channels, only those that mention them or match the regex.

### WebSocket Wait/Subscribe Usage

The `WaitForMessageTool` supports all filter fields. Example input:
```json
{
  "team_id": "t24",
  "backend_host": "localhost:8000",
  "filters": {
    "mention_only": true,
    "channels": ["general"]
  },
  "timeout": 30
}
```
The tool will only return when a message matching the filter is received.

### MCP Tool Integration

- Use the `filters` field in `GetUnreadMessagesTool` and `WaitForMessageTool` for advanced queries.
- For simple use, only `user` is required; all other fields are optional.
- For advanced use, provide any combination of filter fields.

### Upgrading/Installing

To upgrade to the latest version:
```bash
git pull origin main
pip install --force-reinstall --no-cache-dir .
```

### Changelog

#### v0.1.0 (Advanced Filtering Release)
- Add `MessageFilter` model for flexible, future-proof filtering
- Support advanced queries via POST `/messages/query` (REST)
- Wait tool now supports all filter fields for WebSocket
- All filters are optional; simple use cases remain simple
- Backward compatible with legacy GET usage 

### Troubleshooting

#### 422 Unprocessable Content Error

If you receive a 422 error from the backend, it means the request did not match the expected schema for the endpoint.

**Common causes:**
- Using GET `/messages` but sending a JSON body instead of query parameters.
- Using POST `/messages/query` but not sending a valid JSON body matching the `MessageFilter` model.
- Missing required parameters (e.g., `user` for unread tracking).

**How to fix:**
- For GET `/messages`, use only query parameters:
  ```bash
  curl -X GET 'http://localhost:8000/api/team/t24/messages?user=Cline&limit=10'
  ```
- For POST `/messages/query`, use a JSON body:
  ```bash
  curl -X POST 'http://localhost:8000/api/team/t24/messages/query' \
    -H 'Content-Type: application/json' \
    -d '{"user": "Cline", "limit": 10}'
  ```

**Incorrect usage examples:**
- Sending a body with GET:
  ```bash
  curl -X GET 'http://localhost:8000/api/team/t24/messages' -d '{"user": "Cline"}'  # ❌
  ```
- POSTing to `/messages` instead of `/messages/query`:
  ```bash
  curl -X POST 'http://localhost:8000/api/team/t24/messages' -d '{"user": "Cline"}'  # ❌
  ```

**Debugging tips:**
- Check server logs for detailed error messages and request details.
- Ensure your client/tool is using the correct HTTP method and endpoint.
- If using the MCP tool, ensure you pass the `filters` field to trigger the POST endpoint.

If you continue to have issues, review the server logs for the exact error and compare your request to the documented examples above.

### Testing the Tools (test_get_unread_messages.py)

A test script is provided to verify end-to-end connectivity between the MCP tool and the backend chat server. This script can be run locally or in containers, and supports configuration via environment variables or command-line arguments.

**Usage:**

```bash
# All defaults (localhost:8000, team_id=t24, user=Cline)
python test_get_unread_messages.py

# Set backend host only
python test_get_unread_messages.py host.docker.internal:8000

# Set backend host, team, and user via args
python test_get_unread_messages.py host.docker.internal:8000 myteam myuser

# Or use environment variables
export BACKEND_HOST=host.docker.internal:8000
export TEAM_ID=myteam
export USER=myuser
python test_get_unread_messages.py
```

**This script is the recommended way to verify that your MCP tool and backend are communicating correctly in any environment.**

## WaitForMessage Tool Usage

The WaitForMessage tool allows you to wait for a message matching simple criteria on the internal team chat (WebSocket).

### Supported Filters (as top-level fields):
- `from_user` (optional): Only wait for messages from this user. Defaults to the value of the `INTERNAL_CHAT_USER` environment variable if not set.
- `mention_only` (optional, bool): Only wait for messages that mention the user (as set in `INTERNAL_CHAT_USER`). Defaults to `False`.
- `timeout` (optional, int): Timeout in seconds to wait for a message. Defaults to 30.

### Example Usage

Wait for a message from a specific user:
```json
{
  "team_id": "t24",
  "from_user": "greg",
  "timeout": 30
}
```

Wait for a message that mentions the current user:
```json
{
  "team_id": "t24",
  "mention_only": true,
  "timeout": 30
}
```

Wait for a message from a specific user that also mentions you:
```json
{
  "team_id": "t24",
  "from_user": "greg",
  "mention_only": true,
  "timeout": 30
}
```

### Notes
- Only the above filters are supported. Do not use a `filters` object or any other nested structure.
- If neither `from_user` nor `mention_only` is set, the tool will wait for any message.
- The tool is designed for maximum compatibility with MCP, Windsurf, Cursor, and public agent platforms. 

# What's New (May 2025)

- **Robust user context:** All tools now use `INTERNAL_CHAT_USER` from config/env by default for user context and filtering.
- **WaitForMessageTool filtering:**
  - No filters: returns the first message received.
  - `from_user`: only returns messages from that user.
  - `mention_only`: only returns messages that mention the configured user (robust regex).
  - Both: both conditions must be true.
- **SendMessageTool reply_to_user:**
  - If `reply_to_user` is set, the message will automatically mention that user unless already present.
  - This ensures replies always notify the intended recipient, matching modern chat UX.
- **Debugging:**
  - All debug output for WaitForMessageTool is written to `/tmp/wait_for_message_debug.log` for troubleshooting.

## Usage Examples

### Wait for any message
```python
result = WaitForMessageTool().execute(WaitForMessageInput(team_id="t24", timeout=30))
```

### Wait for a mention
```python
result = WaitForMessageTool().execute(WaitForMessageInput(team_id="t24", mention_only=True, timeout=30))
```

### Wait for a message from a specific user
```python
result = WaitForMessageTool().execute(WaitForMessageInput(team_id="t24", from_user="You", timeout=30))
```

### Send a reply that always mentions the sender
```python
SendMessageTool().execute(SendMessageInput(
    team_id="t24",
    user="greg",
    message="Thanks for your message!",
    reply_to_user="You"
))
# This will send: "@You Thanks for your message!"
```

### Mention-based workflow
- Wait for a mention, extract the sender, and reply mentioning them back:
```python
wait_result = WaitForMessageTool().execute(WaitForMessageInput(team_id="t24", mention_only=True, timeout=30))
sender = wait_result.user
SendMessageTool().execute(SendMessageInput(
    team_id="t24",
    user="greg",
    message="Got your mention!",
    reply_to_user=sender
))
```

### Tool Call Parameter Validation and 'from_user' Usage

**Important:**
- The `GetUnreadMessages` tool does **not** accept `from_user` as a top-level field. If you want to filter by sender, use `filters.user` instead.
- Example (correct):
  ```json
  {
    "filters": {"user": "Cline", "limit": 10}
  }
  ```
- Example (incorrect):
  ```json
  {
    "from_user": "Cline", "limit": 10
  }
  ```
  This will be ignored or cause a warning in the logs.

**Agent/Tool-Calling Guidance:**
- Always validate tool call parameters against the tool's schema before calling.
- Drop or remap any fields not in the schema (e.g., move `from_user` into `filters.user` if present).
- If you see errors about invalid parameters, check the tool's schema and usage examples above.

See the `GetUnreadMessagesInput` and `MessageFilter` docstrings for more details and examples. 